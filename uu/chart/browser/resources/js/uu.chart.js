/** uu.chart.js -- javascript for rendering uu.chart chart types from
  * JSON chart API into jqplot charts.
  */

// global namspaces:
var jq = jQuery; /* alias */
$ = jQuery;

var uu = new Object();      /* namespaces */
uu.chart = new Object();

uu.chart.custom_labels = new Object();

uu.sorted = function(arr, cmp) {
    /* return a new sorted array from original */
    if (cmp) return arr.slice().sort(cmp);
    return arr.slice().sort();
}

/**  array max/min for any data-type (req. EC5 Array.prototype.reduce)
  *  prefers non-null values over any null values in sequence always
  *  for both max and min.
  */ 
uu.maxcmp = function (a,b) { return ((a && (a>b)) || !b) ? a : b; }
uu.mincmp = function (a,b) { return ((a && (a<b)) || !b) ? a : b; }
uu.max = function(seq) { return seq.reduce(uu.maxcmp); }
uu.min = function(seq) { return seq.reduce(uu.mincmp); }


uu.chart.normalize_series = function(series) {
    var i,
        element,
        result = new Array();
    for (i=0; i<series.length; i++) {
        element = series[i];
        result.push( [Date.parse(element[0]), element[1]] );
    }
    return result;
}

uu.chart.allkeys = function(data) {
    var rset = new Object(); //use object as fake set-of-names type
    if (data.series) {
        for (var i=0; i<data.series.length; i++) {
            var s = data.series[i];
            if (s.data) {
                var skeys = Object.keys(s.data);
                for (var key in s.data) {
                    rset[key] = 1;
                }
            }
        }
    }
    return uu.sorted(Object.keys(rset));
}

uu.chart.seriesdata = function(data) {
    var r = new Array(),
        s_rep,
        s,
        skeys,
        j,
        key,
        point,
        value;
    if (data.series) {
        for (i=0; i<data.series.length; i++) {
            s_rep = new Array();
            s = data.series[i];
            if (s.data) {
                skeys = uu.sorted(Object.keys(s.data));
                for (j=0; j<skeys.length; j++) {
                    key = skeys[j];
                    point = s.data[key];
                    value = point.value;
                    if (isNaN(value)) {
                        // null object is JSON-compatible sentinel for NaN
                        // values, treated as null for jqPlot to omit display
                        value = null;
                    }
                    if (data.x_axis_type == 'date') {
                        if (Date.parse(key)) {
                            s_rep.push([Date.parse(key), value]);
                        } else {
                            s_rep.push([key, value]);
                        }
                    } else {
                        /* named series elements/points for jqplot are Y-value only:
                            * data-labels are autogenerated, usually from value,
                              * except override via series options pointLabels property.
                            * key implied by consistent order, thus this loop always
                              loops through the series in sorted key order.
                            * X-axis ticks are defined globally for the chart, in order.
                         */
                        s_rep.push(value);
                    }
                }
            }
            r.push(s_rep);
        }
    }
    return r;
}


uu.chart.range = function(data) {
    /* get range min, max: returns two item array of min, max values */
    var min = null,
        max = null,
        s,
        i;
    if (data.series) {
        for (i=0; i<data.series.length; i++) {
            s = data.series[i];
            if ((s.range_min) || (s.range_min === 0)) { 
                if (!min) {
                    min = s.range_min;
                } else {
                    if (min > s.range_min) min = s.range_min;
                }
            }
            if ((s.range_max) || (s.range_max === 0)) { 
                if (!max) {
                    max = s.range_max;
                } else {
                    if (max < s.range_max) max = s.range_max;
                }
            }
        }
    }
    return [min, max];
}

uu.chart.series_colors = function(data) {
    var i,
        s,
        r = jq.jqplot.config.defaultColors.slice(); //copy defaults
    if (data.series) {
        for (i=0; i<data.series.length; i++) {
            s = data.series[i];
            if (s.color) {
                r[i] = s.color; //reassign color, overwrite default
            }
        }
    }
    return r;
}

uu.chart.seriesoptions = function(data) {
    var r = new Array(),
        options,
        marker_options,
        trend_options,
        s;
    if (data.series) {
        for (i=0; i<data.series.length; i++) {
            options = new Object();
            marker_options = new Object();
            trend_options = {show:false};
            s = data.series[i];
            if (s.line_width) options.lineWidth = s.line_width;
            //if (s.color) options.lineColor = s.color;
            // note: line color assigned to seriesColors option for chart, 
            // which takes precedence over options.lineColor
            if (s.marker_style) marker_options.style = s.marker_style;
            if (s.marker_color) marker_options.color = s.marker_color;
            options.markerOptions = marker_options;
            if (s.marker_size) marker_options.size = s.marker_size;
            if (s.marker_width) marker_options.lineWidth = s.marker_width;
            if (s.title) options.label = s.title;
            if (s.units) options.label += ' [&thinsp;' + s.units + '&thinsp;]';
            if (s.show_trend == true) {
                trend_options.show = true;
                if (s.title) {
                    trend_options.label = 'Trend: ' + s.title;
                } else {
                    trend_options.label = 'Trend (linear)';
                }
                if (s.trend_width) {
                    trend_options.lineWidth = s.trend_width;
                } else {
                    trend_options.lineWidth = 1;
                }
                if (s.trend_color) {
                    trend_options.color = s.trend_color;
                }
            }
            options.trendline = trend_options;
            if (s.break_lines) {
                options.breakOnNull = true;
            }
            options.pointLabels = {formatString: "%.1f", hideZeros:false};
            r.push(options);
        }
    }
    return r;
}

uu.chart.bar_config = function(data) {
    /* fitting algorithm: bars between 5 and 32 pixels wide, computed to fit */
    var r = new Object(),
        chart_width = 600;
    if (data.width) chart_width = data.width;
    r.series_length = 0;
    r.max_points = 0;
    if (data.series) r.series_length = data.series.length;
    r.max_points = uu.max(data.series.map(function(series) {
        return Object.keys(series.data).length;
        }));
    r.width = Math.min(32, Math.max(5, (((chart_width * 0.8) / (r.max_points + 1)) / (r.series_length + 1))));
    return r;
}


uu.chart.runchart_start = function(data) {
    var s,
        i,
        result = data.start; //default is null value...
    if (result) {
        // start date plus some padding (one month earlier) for left-hand
        // side of chart.
        return Date.parse(result.slice(0,10)).add(-1).months();
    }
    if (data.series) {
        for (i=0; i<data.series.length; i++) {
            s = data.series[i];
            if (s.data) {
                /* min===earliest date from any series excluding null values */
                result = uu.min([result, uu.min(Object.keys(s.data))]);
            }
        }
    }
    if (Date.today) { //date.js installed
        return Date.parse(result.slice(0,10)).add(-1).months();
    }
    return result.slice(0,10); //date, not datetime in ISO8601
}

uu.chart.savelabels = function (divid, labels) {
    var k, t, m;
    m = {};
    uu.chart.custom_labels[divid] = m;
    for (k in labels) {
        t = parseInt(k);
        m[t] = labels[k];
    }
}

uu.chart.fillchart = function(divid, data) {
    if (data.labels) {
        uu.chart.savelabels(divid, data.labels);
    }
    var legend = {show:false}, //default is none
        legend_placement = 'outsideGrid',
        goal_color = "#333333",
        x_axis = {},
        y_axis = {},
        stack = false,
        series_defaults = {},
        series_colors = jq.jqplot.config.defaultColors,
        barwidth,
        line_width,
        marker_color,
        range,
        labelselect,
        points,
        i,
        j;
    if ((data.chart_type == "bar") || (data.chart_type == "stacked")) {
        barwidth = uu.chart.bar_config(data).width;
        if (data.chart_type == "stacked") {
            stack = true;
            barwidth = barwidth * data.series.length;
        }
        series_defaults = {
            renderer : jq.jqplot.BarRenderer,
            rendererOptions : {
                barWidth : barwidth
                }
            };
        }
    series_colors = uu.chart.series_colors(data);
    line_width = 4;
    marker_color = null;
    if (data.goal) {
        if (data.goal_color) goal_color = data.goal_color;
        series_defaults.thresholdLines = {
            lineColor: goal_color,
            labelColor: goal_color,
            yValues: [data.goal]
        };
    }
    if (data.x_axis_type == 'date') {
        x_axis = {  
            renderer: jq.jqplot.DateAxisRenderer,
            tickInterval:'1 month',
            min: uu.chart.runchart_start(data),
            tickRenderer: jq.jqplot.CanvasAxisTickRenderer,
            tickOptions: {
                angle:-65,
                fontSize:'10pt',
                fontFamily:'Arial',
                fontWeight:'bold',
                enableFontSupport:true,
                textColor:'#00f'
            }
        };
    } else { /* named */
        x_axis.renderer = jq.jqplot.CategoryAxisRenderer;
        //x_axis.ticks = ['groucho','b','c'];
        x_axis.ticks = uu.chart.allkeys(data);
    }
    if ((data.legend_location) && (data.series.length > 1)) {
        if (data.legend_placement) {
            legend_placement = data.legend_placement;
        }
        legend = {show:true, location:data.legend_location, placement:legend_placement, marginTop:'2em'};
    }
    if (data.y_label) {
        y_axis.label = data.y_label;
        if (data.units) {
            y_axis.label += ' ( ' + data.units + ' )';
        }
        if (jq.jqplot.CanvasAxisLabelRenderer) {
            y_axis.labelRenderer = jq.jqplot.CanvasAxisLabelRenderer;
            y_axis.labelOptions = { fontFamily:'Helvetica,Arial,Sans Serif', fontSize:'12pt' };
        }
    }
    range = uu.chart.range(data);
    if (range[0]) { /*min*/
        y_axis.min = range[0];
    }
    if (range[1]) { /*max*/
        y_axis.max = range[1];
    }
    if (data.x_label) {
        x_axis.label = data.x_label;
    }
    jq.jqplot.config.enablePlugins = true;
    jq.jqplot(divid, uu.chart.seriesdata(data), {
        stackSeries: stack,
        axes:{xaxis:x_axis, yaxis:y_axis},
        axesDefaults: {tickOptions: {fontSize:'7pt'}},
        series:uu.chart.seriesoptions(data),
        seriesDefaults: series_defaults,
        legend: legend,
        seriesColors : series_colors
        });
    // finally, adjust label colors to match line colors using CSS/jQuery:
    for (i=0; i<series_colors.length; i++) {
        labelselect = '#' + divid + ' .jqplot-series-' + i + '.jqplot-point-label';
        points = jq(labelselect);
        for (j=0; j<points.length; j++) {
            point = jq(points[j]);
            if (data.chart_type == "stacked") {
                v = parseInt(point.html());
                if (v < 20) {
                    point.css('margin-left', '2.2em');
                }
                point.css('backgroundColor', series_colors[i]);
                point.css('padding', '0 0.2em');
                point.css('margin-top', '3em');
            } else {
                point.css('color', series_colors[i]);
            }
        }
    }
}

uu.chart.biggest_label = function (labels) {
    var k,
        v,
        biggest=0;
    for (k in labels) {
        v = labels[k];
        if (v.length > biggest) biggest = v.length;
    }
    return biggest;
};

uu.chart.custom_label = function (plotid, value) {
    var k, m, v, lkeys, padding;
    k = value.toString();
    m = uu.chart.custom_labels[plotid];
    if (!m) return null;
    lkeys = Object.keys(m);
    padding = uu.chart.biggest_label(m);
    if (jQuery.inArray(k, lkeys) != -1) {
        return ('        ' + m[k]).slice(-1*padding);
    }
    if (m) {
        return ' ';
    }
    return null;
};

uu.chart.loadcharts = function () {
    // copy original tick-label draw method on CanvasAxisTickRenderer
    // prototype, to make available to a monkey patched method:
    jQuery.jqplot.CanvasAxisTickRenderer.prototype.orig_draw = jQuery.jqplot.CanvasAxisTickRenderer.prototype.draw;

    // wrapper tick-label draw method supporting custom labels:
    new_draw = function (ctx, plot) {
        // use plot.target[0].id (plot div id), this.value for custom label
        var custom_label = uu.chart.custom_label(plot.target[0].id, this.value);
        if (custom_label !== null) this.label = custom_label;
        return this.orig_draw(ctx, plot);  // call orig in context of this
    }

    //monkey patch original tick-label draw method with wrapper
    jQuery.jqplot.CanvasAxisTickRenderer.prototype.draw = new_draw;

    jq('.chartdiv').each(function(index) {
        var div = jq(this),
            json_url = jq('a[type="application/json"]', div).attr('href'),
            divid = div.attr('id'); 
        jq.ajax({
            url: json_url,
            success: function(responseText) { /*callback*/
                if (!uu.chart.saved_data) uu.chart.saved_data = {};
                uu.chart.saved_data[divid] = responseText;
                uu.chart.fillchart(divid, responseText);
            }
        });
    });
}


jq('document').ready(function(){
    uu.chart.loadcharts();
});

